<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { checkCollision } from './utils/collision.js';

/** @module @tinycanvas */

/**
 * Game options
 * 
 * @public
 * @typedef {Object} GameOptions
 * @property {string} [canvasElement="game"] ID of custom canvas element 
 */

/**
 * GameObject options
 * 
 * @public
 * @typedef {Object} GameObjectOptions
 * @property {*} init Function called on initilisation
 * @property {*} render Function called on every frame
 * @property {boolean | GameObject[]} collision true if callback regardless of GameObject, or an array of GameObjects to specifically collide with
 * @property {*} onCollision collision callback
 * @property {Array} interactions array of interaction functions to initilise. See CLH.Interactions for defaults
 */

/**
 * Listener
 * 
 * @public
 * @typedef {Object} Listener
 * @property {(START)} type - Listener key
 * @property {*} callback - Callback
 */

/**
 * This is the base object.
 * 
 * @public
 */
class GameObject {
    x = 0;
    y = 0;
    delta = 0;
    h = 0;
    w = 0;
    r = 0;
    _collision = false;
    _x0 = 0;
    _y0 = 0;

    /**
     * 
     * @param {Game} game 
     * @param {GameObjectOptions} opts 
     */
    constructor(game, opts) {
        this.game = game;
        this.opts = opts;
        this.id = `${opts?.name || ''}_${Math.floor(Math.random() * 100)}`

        if (opts?.collision) {
            this._collision =  true;
            if (Array.isArray(opts.collision)) this._collisionObjects = opts.collision;
        }

        if (this.opts?.init) this.opts.init(this);
        if (this.opts?.interactions) this.opts.interactions.forEach((i => i.init(this)));
    }
    render() {
        if (this._collision &amp;&amp; (this.x !== this._x0 || this.y !== this._y0)) {
            const collision = this._checkCollisions();
            if (collision &amp;&amp; this.opts.onCollision) {
                this.opts?.onCollision(this, collision);
            } else if (collision) {
                this.x = this._x0;
                this.y = this._y0;
                return;
            }
            this._x0 = this.x;
            this._y0 = this.y;
        }
        this.opts.render(this);
    }
    _checkCollisions() {
        const objs = this._collisionObjects?.length > 0
            ? this._collisionObjects
            : this.game.getObjects().filter((g) => g.id !== this.id &amp;&amp; g.collision);
        for(let o of objs) {
            if (checkCollision(this, o)) {
                return o;
            }
        }
        return false;
    }
}

class Game {
    _images = [];

    _sounds = [];

    /**
     * @type {Listener[]}
     */
    _listeners = [];

    _objects = [];

    constructor(opts) {
        this.opts = opts;
        this.canvas = document.getElementById(opts?.canvasElement || 'game');
        this.context = this.canvas.getContext('2d');
    }

    add = {
        object: (opts) => {
            const o = new GameObject(this, opts);
            this._objects.push(o);
            return o;
        },
        image: (key, src) => {
            const image = new Image();
            image.id = key;
            image.src = src;
            this._images.push(image);
            return image;
        },
        sound: (key, src) => {
            const sound = new Audio();
            sound.id = key;
            sound.src = src;
            this._sounds.push(sound);
            return sound;
        }
    }
    start() {
        if (this._images.some((i) => !i.complete)) {
            setTimeout(this.start.bind(this), 100);
            return;
        }
        this._sendEvent('START');
        this._loop();
    }
    on(type, callback) {
        this._listeners.push({ type, callback });
    }
    getObjects() {
        return this._objects;
    }
    _loop() {
        this._clear();
        this._render();
        window.requestAnimationFrame(this._loop.bind(this));
    }
    _clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    _render() {
        for (let o of this._objects) {
            o.render();
        }
    }
    _sendEvent(type) {
        for(let e of this._listeners) {
            if (e.type === type) e.callback();
        }
    }
}

/**
 * Creates a game
 *
 * @function
 * @property {GameOptions} opts 
 */
function create(opts) {
    return new Game(opts);
}

/**
 * @public
 * @module @tinycanvas
 * @property {create} create - Creates a game
 */
export default {
    create,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-@clh_animations.html">@clh/animations</a></li><li><a href="module-@clh_interactions.html">@clh/interactions</a></li><li><a href="module-@tinycanvas.html">@tinycanvas</a></li></ul><h3>Classes</h3><ul><li><a href="module-@tinycanvas-GameObject.html">GameObject</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Dec 30 2021 19:40:40 GMT+1000 (Australian Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
